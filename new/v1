#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pwd.h>
#include <string.h>
#include <errno.h>
#include <time.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <grp.h>





#define TOKEN_DIR "/etc/asusr"
#define TOKEN_MAX 128
void log_action(const char *caller,
                const char *target,
                char *const argv[],
                int status)
{
    char path[256];
    snprintf(path, sizeof(path),
             "/var/log/asuser/%s.log", target);

    int fd = open(path, O_WRONLY | O_CREAT | O_APPEND, 0640);
	

    if (fd < 0)
        return;
	fchown(fd, getpwnam(target)->pw_uid, 0);
    time_t now = time(NULL);
    struct tm *tm = localtime(&now);

    char ts[64];
    strftime(ts, sizeof(ts), "%Y-%m-%d %H:%M:%S", tm);

    dprintf(fd, "[%s] %s -> %s : ",
            ts, caller, target);

    for (int i = 2; argv[i]; i++)
        dprintf(fd, "%s ", argv[i]);

    dprintf(fd, "exit=%d\n",
            WIFEXITED(status) ? WEXITSTATUS(status) : -1);

    close(fd);
}

int read_token(const char *user,char *buf,size_t buflen)
{
	char path[256];
	snprintf(path,sizeof(path),"%s/%s.token", TOKEN_DIR, user);
	
	FILE *f =fopen(path, "r");
	if (!f) return -1;
	
	if (!fgets(buf, buflen,f)) 
{
	fclose(f);
	return -1;
}
	buf[strcspn(buf,  "\n")] =0;
	fclose(f);
	return 0;
}
int main(int argc, char* argv[])
{
	char input[TOKEN_MAX];
	char stored[TOKEN_MAX];
    if (argc<3)
    {
        fprintf(stderr, "Usage: asuser <target_user> <command> [args...]\n");
        return 1;
    }
    uid_t caller_uid= getuid();
	if (caller_uid == 0)
{
	fprintf(stderr, "why the hell are you running as root?");
	return 1;
}
    struct passwd *caller_pw = getpwuid(caller_uid);
    if (!caller_pw) {
	perror("getpwuid");
	return 1;
}

printf("caller user: %s\n",caller_pw->pw_name);

struct passwd *target_pw = getpwnam(argv[1]);
if (!target_pw){
	fprintf(stderr, "unknown target user:%s\n",argv[1]);
	return 1;
}
	printf("Traget_UID : %d\n",target_pw->pw_uid);
	printf("Target_GID : %d\n",target_pw->pw_gid);
	
if (read_token(target_pw->pw_name, stored, sizeof(stored)) != 0){
	fprintf(stderr , "no token found for the user\n");
	return 1;
}
	printf("asuser token:");
	fflush(stdout);

if (!fgets(input, sizeof(input),stdin)){
	fprintf(stderr, "failed to read token \n");
	return 1;
}
input [strcspn(input, "\n")] = 0;
if (strcmp(input,stored) !=0 ) {
	fprintf(stderr, "authentication failed ");
	return 1;
}
		
   pid_t pid = fork();
if (pid < 0) {
    perror("fork");
    return 1;
}

if (pid == 0) {
    /* CHILD */
if (setgroups(0, NULL) != 0) {
    perror("setgroups");
    _exit(1);
}


    /* drop group privileges first */
    if (setgid(target_pw->pw_gid) != 0) {
        perror("setgid");
        _exit(1);
    }

    /* drop effective UID only */
    if (seteuid(target_pw->pw_uid) != 0) {
        perror("seteuid");
        _exit(1);
    }

    execvp(argv[2], &argv[2]);
    perror("execvp");
    _exit(1);
}

int status;
waitpid(pid, &status, 0);



log_action(caller_pw->pw_name,
           target_pw->pw_name,
           argv,
           status);

return 0;


}
